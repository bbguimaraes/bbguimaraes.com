<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>C++ virtual tables</title>
        <link rel="stylesheet" type="text/css" href="/main.css" />
        <link rel="stylesheet" type="text/css" href="blog.css" />
        <script type="module" src="/main.js"></script>
        <link
            rel="alternate" type="application/rss+xml" title="RSS"
            href="https://bbguimaraes.com/blog/rss.xml" />
    </head>
    <body class="w80">
        <nav id="page-nav">
            <a href="/"><img id="logo" src="/triangle_icon.png" alt="root" /></a>
            /
            <a href=".">blog</a>
            /
            C++ virtual tables
            <a id="rss-icon" href="/rss.xml"><img src="/files/rss.png" alt="rss" /></a>
        </nav>
        <main class="blog">
            <h1>C++ virtual tables</h1>
            <p><i>2022-02-22T20:09:10</i></p>
            <p>
One of the principal differences between C and C++ is the latter's direct
support for virtual functions.  While it is entirely possible, as will be
demonstrated, to implement virtual dispatch in C, C++ offers language primitives
that instruct the compiler to generate the necessary back end code
automatically.
            </p>
            <p>
At the center of most implementations is the <i>virtual table</i>.  Each object
with virtual functions has an associated structure containing function pointers
that direct the program to the implementation of the object's methods.  This
article explores the contents of the virtual tables generated by compilers to
implement virtual dispatch in C++.  It is based on the GCC implementation, which
follows the <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html">Itanium
ABI</a>.  In particular:
            </p>
            <ul>
                <li>
                    <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-components">
                        section 2.5.2: <i>Virtual Table Components and Order</i>
                    </a>
                </li>
                <li>
                    <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-components">
                        section 2.5.3: <i>Virtual Table Construction</i>
                    </a>
                </li>
                <li>
                    <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vcall">
                        section 3.2: <i>Virtual Calls</i>
                    </a>
                </li>
            </ul>
            <aside>
                <p>
The text is divided into sections, mostly following the class categories in the
document, with some ancillary  material around them:
                </p>
                <ul>
                    <li>
                        <a href="#motivation">Motivation</a>
                    </li>
                    <li>
                        <a href="#code-generation">Code generation</a>
                    </li>
                    <li>
                        Class categories
                        <ul>
                            <li>
                                <a href="#trivial">Trivial</a>
                            </li>
                            <li>
                                <a href="#leaf">Leaf</a>
                            </li>
                            <li>
                                <a href="#general-single-inheritance">
                                    General single inheritance
                                </a>
                            </li>
                            <li>
                                <a href="#non-virtual-bases-only">
                                    Non-virtual bases only
                                </a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="#references">References</a>
                    </li>
                    <li>
                        <a href="#notes">Notes</a>
                    </li>
                </ul>
                <p>
Links to source files are placed throughout the text.  They are also available
in the <a href="https://gitlab.bbguimaraes.com/bbguimaraes/bbguimaraes.com.git">repository</a>.
                </p>
            </aside>
            <p>
To limit the scope to even a reasonably long description, virtual inheritance is
almost completely disregarded.  It significantly complicates the implementation,
but is mostly orthogonal &mdash; if related &mdash; to the concepts presented
here.  It will be mentioned briefly in cases where it influences the table
layout, but the discussion of several aspects will omit the details that pertain
to virtual inheritance (e.g. the "trivial" case is described as an object with
no virtual functions, when in fact it has the additional restriction of having
no virtual bases).  Readers interested in the details are encouraged to consult
the original document.
            </p>
            <h2 id="motivation">
                <a href="#motivation">
                    Motivation
                </a>
            </h2>
            <p>
Our goal is to explore the organization of virtual tables and the operations
performed by the compiler to implement virtual calls.  Along the way, we will
develop a C implementation that is byte-by-byte identical to the one generated
by the compiler.
            </p>
            <p>
To demonstrate how accurate this reproduction is, here is a C++ program which
declares a class hierarchy with multiple inheritance similar to the one
presented at the end of this article:
            </p>
            <a class="src-ref" href="c++-virtual-tables/motivation/test.cpp">test.cpp</a>
            <pre><code><b>struct</b> S { <b>virtual</b> <b>void</b> sf(<b>void</b>); };
<b>struct</b> T { <b>virtual</b> <b>void</b> tf(<b>void</b>); };

<b>struct</b> U : S, T {
    <b>void</b> tf(<b>void</b>) override;
    <b>virtual</b> <b>void</b> uf(<b>void</b>);
};

<b>struct</b> V : U {
    <b>void</b> tf(<b>void</b>) override;
    <b>void</b> uf(<b>void</b>) override;
    <b>virtual</b> <b>void</b> vf(<b>void</b>);
};</code></pre>
            <p>
The program contains objects of each class and performs a series of operations
on them.  However, only <code>V</code>, the bottom of the hierarchy, is defined
by the C++ source:
            </p>
            <pre>
$ objdump --syms --demangle test.o
<i>[…]</i>
0000000000000000  w    O .data.rel.ro._ZTV1V	0000000000000048 vtable for V
0000000000000000  w    F .text._ZN1V2tfEv	0000000000000015 V::tf()
0000000000000000  w    F .text._ZN1V2ufEv	000000000000003a V::uf()
0000000000000000  w    F .text._ZN1V2vfEv	0000000000000015 V::vf()
0000000000000020  w    F .text._ZN1V2tfEv	0000000000000015 non-virtual thunk to V::tf()
0000000000000000 g     F .text.startup	0000000000000104 main
<i>[…]</i>
            </pre>
            <p>
Where are the other definitions?  I am glad you asked:
            </p>
            <pre>
$ make --always-make test
g++ -O2 -fno-rtti   -c -o test.o <a href="c++-virtual-tables/motivation/test.cpp">test.cpp</a>
cc -O2   -c -o evil.o <a href="c++-virtual-tables/motivation/evil.c">evil.c</a>
g++ -o test test.o evil.o
$ objdump --syms --demangle evil.o
<i>[…]</i>
0000000000000060 g     O .data.rel.ro.local	0000000000000018 vtable for S
0000000000000040 g     O .data.rel.ro.local	0000000000000018 vtable for T
0000000000000000 g     O .data.rel.ro.local	0000000000000038 vtable for U
0000000000000000 g     F .text	000000000000001c S::sf()
0000000000000020 g     F .text	000000000000001c T::tf()
0000000000000040 g     F .text	000000000000001c U::uf()
0000000000000060 g     F .text	0000000000000044 non-virtual thunk to U::tf()
00000000000000b0 g     F .text	000000000000001c U::tf()
00000000000000d0 g     F .text	000000000000002d f(S*)
0000000000000100 g     F .text	000000000000002d f(T*)
0000000000000130 g     F .text	0000000000000041 f(U*)
0000000000000000 g     O .data.rel.local	0000000000000010 u
0000000000000010 g     O .data.rel.local	0000000000000008 t
0000000000000018 g     O .data.rel.local	0000000000000008 s
<i>[…]</i>
            </pre>
            <p>
Here is the C++ part of the program and its output:
            </p>
            <details>
                <summary>C++ source</summary>
                <a class="src-ref" href="c++-virtual-tables/motivation/test.cpp">test.cpp</a>
                <pre><code><b>#include</b> &lt;cstdio&gt;

<i>// base and derived classes declared in C++</i>
<b>struct</b> S {
    <i>// base function</i>
    <b>virtual</b> <b>void</b> sf(<b>void</b>);
};

<b>struct</b> T {
    <i>// base function overridden in derived</i>
    <b>virtual</b> <b>void</b> tf(<b>void</b>);
};

<b>struct</b> U : S, T {
    <i>// overridden function</i>
    <b>void</b> tf(<b>void</b>) <b>override</b>;
    <i>// own virtual function</i>
    <b>virtual</b> <b>void</b> uf(<b>void</b>);
};

<i>// derived class defined in C++</i>
<b>struct</b> V : U {
    <b>void</b> tf(<b>void</b>) <b>override</b> { std::printf(<b>"V::tf() in %s\n"</b>, <b>__FILE__</b>); }
    <b>void</b> uf(<b>void</b>) <b>override</b> {
        std::puts(<b>"\n=== C++ obj -&gt; C++ offset -&gt; C base impl ===\n"</b>);
        U::uf();
        std::puts(<b>"\n=== C++ obj -&gt; C++ offset -&gt; C derived impl ===\n"</b>);
        std::printf(<b>"V::uf() in %s\n"</b>, <b>__FILE__</b>);
    }
    <b>virtual</b> <b>void</b> vf(<b>void</b>) { std::printf(<b>"V::vf() in %s\n"</b>, <b>__FILE__</b>); }
};

<i>// C++ objects defined in C</i>
<b>extern</b> S s;
<b>extern</b> T t;
<b>extern</b> U u;

<i>// C++ functions defined in C</i>
<b>void</b> f(S *p);
<b>void</b> f(T *p);
<b>void</b> f(U *p);

<b>int</b> main(<b>void</b>) {
    std::puts(<b>"=== C obj -&gt; C impl ===\n"</b>);
    f(&amp;s);
    f(&amp;t);
    std::puts(<b>"\n=== C obj -&gt; C++ offset -&gt; C base impl ===\n"</b>);
    f(<b>static_cast</b>&lt;S*&gt;(&amp;u));
    std::puts(<b>"\n=== C obj -&gt; C++ offset -&gt; C prelude -&gt; C derived impl ===\n"</b>);
    f(<b>static_cast</b>&lt;T*&gt;(&amp;u));
    std::puts(<b>"\n=== C obj -&gt; C impl -&gt; virtual calls ===\n"</b>);
    f(&amp;u);
    V v;
    std::puts(<b>"\n=== C++ obj -&gt; C++ offset -&gt; C base impl ===\n"</b>);
    <b>static_cast</b>&lt;S*&gt;(&amp;v)-&gt;sf();
    std::puts(<b>"\n=== C++ obj -&gt; C++ offset -&gt; C++ derived impl ===\n"</b>);
    <b>static_cast</b>&lt;T*&gt;(&amp;v)-&gt;tf();
    <b>static_cast</b>&lt;U*&gt;(&amp;v)-&gt;uf();
    std::puts(<b>"\n=== C++ obj -&gt; C++ impl ===\n"</b>);
    (&amp;v)-&gt;vf();
}</code></pre>
            </details>
            <details>
                <summary>Output</summary>
                <pre>
=== C obj -> C impl ===

f(S*) in evil.c
S::sf() in evil.c
f(T*) in evil.c
T::tf() in evil.c

=== C obj -> C++ offset -> C base impl ===

f(S*) in evil.c
S::sf() in evil.c

=== C obj -> C++ offset -> C prelude -> C derived impl ===

f(T*) in evil.c
non-virtual thunk to U::tf() in evil.c
U::tf() in evil.c

=== C obj -> C impl -> virtual calls ===

f(U*) in evil.c
S::sf() in evil.c
non-virtual thunk to U::tf() in evil.c
U::tf() in evil.c
U::uf() in evil.c

=== C++ obj -> C++ offset -> C base impl ===

S::sf() in evil.c

=== C++ obj -> C++ offset -> C++ derived impl ===

V::tf() in test.cpp

=== C++ obj -> C++ offset -> C base impl ===

U::uf() in evil.c

=== C++ obj -> C++ offset -> C derived impl ===

V::uf() in test.cpp

=== C++ obj -> C++ impl ===

V::vf() in test.cpp
                </pre>
            </details>
            <p>
By the end of this article, you will have the knowledge to do such horrible
things to your C++ compiler.
            </p>
            <h2 id="code-generation">
                <a href="#code-generation">
                    Code generation
                </a>
            </h2>
            <p>
The analysis that follows will contain several source code listings.  Examples
will be presented in C++ paired with their generated machine code and data.
The exposition of the underlying implementation will be written in C, so as to
have no interference that may be mistaken as a power only available to the
compiler.
            </p>
            <p>
Machine code is generated using GCC, currently at version 11.2.0, using the
<code>-O2</code>, <code>-fno-exceptions</code>, and <code>-fno-rtti</code>
arguments.  Machine code disassembly is generated either using GCC's
<code>-S</code> flag, which skips the assembly stage, or by direct analysis of
the generated object files using <code>objdump</code>.  All code was generated
on an x86-64 Linux machine.
            </p>
            <p>
The generated assembly is filtered through <code>c++filt</code> in order to
present names without mangling.  Listings may omit details that are not relevant
to the topic being discussed.  Also, due to aggressive inlining done by the
compiler, some examples may not generate exactly the same code as presented.
Some liberty has been taken in combining code generated after the addition of
compiler instructions of various sorts, but only when they remained truthful to
the code presented, modulo visibility from being declared in the same
translation unit.  The most notable instances have dedicated notes with detailed
explanations.
            </p>
            <details class="code-details">
                <summary>Examples</summary>
                <pre><code>$ cat test.c
<b>int</b> main(<b>void</b>) {
    <b>return</b> <b>0</b>;
}</code></pre>
                <pre><code>$ gcc -S -O2 -masm=intel -o - test.c
        .file   "test.c"
        .intel_syntax noprefix
        .text
        .section        .text.startup,"ax",@progbits
        .p2align 4
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        <b>xor</b>     <b>eax</b>, <b>eax</b>
        <b>ret</b>
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  "GCC: (GNU) 11.2.0"
        .section        .note.GNU-stack,"",@progbits</code></pre>
            <pre><code>$ gcc -O2 -c test.c
$ objdump --disassemble --disassembler-options intel test.o


test.o:     file format elf64-x86-64


Disassembly of section .text.startup:

0000000000000000 &lt;main&gt;:
   0:   31 c0                   <b>xor</b>    <b>eax</b>,<b>eax</b>
   2:   c3                      <b>ret</b></code></pre>
                <pre><code>$ c++filt &lt;&lt;&lt; _ZN1S1fEv
S::f()</code></pre>
            </details>
            <h2 id="trivial">
                <a href="#trivial">
                    Trivial
                </a>
            </h2>
            <p>
The Itanium ABI document distinguishes virtual tables for several types of class
hierarchies.  All types have the same general layout, but some cases do not
require all sections.  The simplest of these is the trivial class, which has no
virtual functions: objects of these classes have no need for a virtual table,
and so none is generated and the objects do not contain a virtual pointer.
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/trivial.cpp">trivial.cpp</a>
            </div>
            <pre class="inline-code"><code><b>struct</b> {
    <b>void</b> f(<b>void</b>);
} s;

<b>void</b> f(<b>void</b>) {
    s.f();
}</code></pre>
            <pre class="inline-code"><code>f():
    <b>lea</b> <b>rdi</b>, s[<b>rip</b>]
    <b>jmp</b> ._anon_0::f()@PLT
s:
    <b>.zero</b> <b>1</b></code></pre>
            <p>
The code is as simple as it can be.  <code>s</code> has no data members, so it
is declared as a single-byte object<a href="#note0"><sup>0</sup></a>.  The free
function <code>f</code> loads the address to be used as the <code>this</code>
pointer into <code>rdi</code><a href="#note1"><sup>1</sup></a> (as mandated by
the ABI) and transfers control to the object's <code>f</code> method.
            </p>
            <h2 id="leaf">
                <a href="#leaf">
                    Leaf
                </a>
            </h2>
            <p>
A leaf class has virtual functions of its own but does not inherit any.  A
virtual table will be generated for it, and a pointer to that table will be
present at the beginning of each class instance.
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/leaf.cpp">leaf.cpp</a>
            </div>
            <pre class="inline-code"><code><b>struct</b> S {
    <b>virtual</b> <b>void</b> f(<b>void</b>) {}
} s;</code></pre>
            <pre class="inline-code"><code>S::f():
    <b>ret</b>
vtable for S:
    <b>.quad</b> <b>0</b>      <i># offset to top</i>
    <b>.quad</b> <b>0</b>      <i># typeinfo*</i>
    <b>.quad</b> S::f() <i># virtual functions</i>
s:
    <b>.quad</b> vtable for S+16</code></pre>
            <p>
Three symbols have been generated for this code (<code>_ZN1S1fEv</code>,
<code>_ZTV1S</code>, and <code>s</code> are their unadulterated mangled names),
placed in the final executable in the <code>.text</code>,
<code>.data.rel.ro</code>, and <code>.data</code> sections, respectively.  They
are: the implementation of <code>S::f</code>, the virtual table for class
<code>S</code>, and the global object <code>s</code>.
            </p>
            <p>
The function <code>S::f</code> is empty, as expected.  It is defined just so the
compiler has enough information to generate the virtual table.  The object
<code>s</code> would also be empty, since it has no data members, but the
compiler has added a hidden <i>virtual pointer</i> to it.  The Itanium ABI
document calls classes such as <code>S</code> whose only effective data member
is the virtual pointer <i>nearly empty classes</i>.
            </p>
            <p>
Finally, the virtual table itself is composed of three <code>quad</code> (i.e.
64-bit) words.  They are, as indicated by the comments:
            </p>
            <ol start="0">
                <li>
                    <i>Offset to top</i>: this value is used in the
                    implementation of <code>dynamic_cast</code> and is not
                    relevant for this article.  It is always zero under single
                    inheritance.
                </li>
                <li>
                    <i><code>typeinfo</code> pointer</i>: pointer to the object
                    used for <i>run-time type information</i> (RTTI).  It will
                    be zero/<code>nullptr</code> in all examples since they are
                    compiled with RTTI disabled.
                </li>
                <li>
                    <i>Virtual function pointers</i>: this is the array which
                    gives virtual tables their name.  In this case, it has a
                    single entry: the address of <code>S::f</code>.
                </li>
            </ol>
            <p>
Note that the virtual pointer in <code>s</code> points to the third element of
the table (16 bytes from the beginning), not to the top.  Thus, given an object
of type <code>S</code>, a virtual method can be called in the following manner<a
href="#note2"><sup>2</sup></a>:
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/leaf.cpp">leaf.cpp</a>
            </div>
            <pre class="inline-code"><code><b>void</b> f(S *p) {
    p-&gt;f();
}</code></pre>
            <pre class="inline-code"><code>f(S*):
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>jmp</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]</code></pre>
            <p>
The first step is to dereference the pointer <code>p</code> to get to the
object.  As described above, the virtual pointer is placed at the beginning of
each object, and it points directly to the function pointer array, which in this
case has a single entry.  <code>p</code> is already in the register which
corresponds to the first argument and points to the derived object, so calling
the virtual function <code>f</code> is a simple matter of doing the required
triple-dereference to transfer execution to method.
            </p>
            <aside>
                <p>
A quick reference for those unfamiliar with x86 assembly:
                </p>
                <ul>
                    <li>
                        <code>rdi</code>: the register containing the first
                        function parameter (<code>p</code>).
                    </li>
                    <li>
                        <code>[rdi]</code>: dereference the pointer contained in
                        the <code>rdi</code> register.
                    </li>
                    <li>
                        <code><i>n</i>[rdi]</code>: apply an immediate offset
                        before dereferencing the pointer, as in the C expression
                        <code>array[n]</code><a href="#note3"><sup>3</sup></a>.
                    </li>
                    <li>
                        <code>mov …, QWORD PTR […]</code>: copy the pointed-to,
                        64-bit (<b>q</b>uad <b>word</b>) value.
                    </li>
                    <li>
                        <code>jmp [QWORD PTR [rax]]</code>: set the instruction
                        pointer to the result of dereferencing the
                        <code>rax</code> register twice, both times as 64-bit
                        values.
                    </li>
                </ul>
                <p>
The equivalent code in pseudo-C would be:
                </p>
                <pre><code><b>extern</b> <b>u64</b> rdi;
<b>u64</b> **rax = *(<b>u64</b>***)rdi; <i>// mov</i>
<b>goto</b> **rax; <i>// jmp</i></code></pre>
                <p>
Using a fictitious triple-dereference addressing mode, the same could be
achieved with <code>jmp [QWORD PTR [QWORD PTR [rdi]]]</code> (i.e. <code>goto
***rdi</code>).  This is reflected in the triple indirection using the
<code>-&gt;</code> and <code>()</code> operators in the C implementation below.
                </p>
            </aside>
            <p>
And finally, adding more virtual functions to <code>S</code> simply extends the
table.  Functions are added in order of declaration.  An offset is required in
the second-to-last dereference to obtain the correct function
pointer<a href="#note4"><sup>4</sup></a>.  Adding data members has no effect on
this layout since they are placed after the virtual pointer.  Base classes
similarly have no effect, since their data members are placed between the
virtual pointer and the derived data members (they have no virtual functions
since this is a leaf class).
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/leaf_fns_inline.cpp">leaf_fns_inline.cpp</a>
            </div>
            <pre class="inline-code"><code><b>struct</b> S {
    <b>virtual</b> <b>void</b> f(<b>void</b>) {}
    <b>virtual</b> <b>void</b> g(<b>void</b>) {}
    <b>virtual</b> <b>void</b> h(<b>void</b>) {}
};

<b>void</b> f(S *p) {
    p-&gt;f(), p-&gt;g(), p-&gt;h();
}</code></pre>
            <pre class="inline-code"><code>vtable for S:
    <b>.quad</b> <b>0</b>
    <b>.quad</b> <b>0</b>
    <b>.quad</b> S::f()
    <b>.quad</b> S::g()
    <b>.quad</b> S::h()
f:
    <b>push</b> <b>rbp</b>
    <b>mov</b>  <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b>  <b>rbp</b>, <b>rdi</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
    <b>mov</b>  <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b>  <b>rdi</b>, <b>rbp</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> <b>8</b>[<b>rax</b>]]
    <b>mov</b>  <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b>  <b>rdi</b>, <b>rbp</b>
    <b>pop</b>  <b>rbp</b>
    <b>mov</b>  <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]
    <b>jmp</b>  <b>rax</b></code></pre>
            <h3>Implementation</h3>
            <p>
From the description above, we can start to derive an implementation equivalent
to that generated by the compiler.  First, we declare the header present in
every table.
            </p>
            <a class="src-ref" href="c++-virtual-tables/leaf.c">leaf.c</a>
            <pre><code><b>struct</b> typeinfo;

<b>struct</b> vtable_header {
    <b>ptrdiff_t</b> offset_to_top;
    <b>const</b> <b>struct</b> typeinfo *typeinfo;
};</code></pre>
            <p>
The definition of <code>struct typeinfo</code> is not interesting, so it is
declared but left undefined, which is enough to form a pointer to it and include
it as a member.  This header is used only to describe and adhere to the layout,
its members will be zero (and implicitly zero-initialized).
            </p>
            <p>
Next, the virtual table for <code>S</code>, which consists of the header and a
function pointer for each virtual function.  It takes as its first argument a
pointer to the object, as is done implicitly in C++.  <code>S</code> objects are
no longer empty: they now contain a pointer to the function pointer array in the
virtual table.
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/leaf.c">leaf.c</a>
            </div>
            <pre class="inline-code"><code><b>struct</b> S;

<b>struct</b> S_vtable {
    <b>void</b> (*<b>const</b> f)(<b>struct</b> S*);
};

<b>void</b> S_f(<b>struct</b> S*) {}

<b>const</b> <b>struct</b> {
    <b>const</b> <b>struct</b> vtable_header header;
    <b>const</b> <b>struct</b> S_vtable vtable;
} S_vtable = {
    .vtable.f = S_f,
};

<b>struct</b> S {
    <b>const</b> <b>struct</b> S_vtable *vptr;
};

<b>struct</b> S s = {
    .vptr = &amp;S_vtable.vtable,
};</code></pre>
            <pre class="inline-code"><code>S_f:
    <b>ret</b>
S_vtable:
    <b>.zero</b> <b>16</b>
    <b>.quad</b> S_f
s:
    <b>.quad</b> S_vtable+16</code></pre>
            <p>
We can then implement the virtual call, which uses the function pointer in the
virtual table arrived at via the virtual pointer:
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/leaf.c">leaf.c</a>
            </div>
            <pre class="inline-code"><code><b>void</b> f(<b>struct</b> S *p) {
    p-&gt;vptr-&gt;f(p);
}</code></pre>
            <pre class="inline-code"><code>f:
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>jmp</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]</code></pre>
            <h2 id="general-single-inheritance">
                <a href="#general-single-inheritance">
                    General single inheritance
                </a>
            </h2>
            <p>
While not discriminated in the document, this category has enough distinguishing
characteristics from the others to be presented in its own section.  These are
classes which inherit virtual functions through single inheritance only, i.e.
each class in the hierarchy inherits from a single base.  Their <i>inheritance
graph</i> is a single straight line.
            </p>
            <p>
Surprisingly little has to be added to support this case, which is one reason
why single inheritance is universally supported while languages often forbid
multiple and virtual inheritance.  Since each class has a single base, their
objects are all simple concatenations of all classes in the hierarchy and all
objects in the hierarchy are inter-convertible<a href="#note5"><sup>5</sup></a>.
In other words, they all point to the same block of memory and differ only in
how much of that memory each class is aware of.  Similarly, their lists of
virtual functions are all simple concatenations of each hierarchy.
            </p>
            <p>
Since a pointer to a derived class can be passed to a function in one of its
bases unchanged and the derived virtual table can be used by any of its bases
also unchanged, the only requirement to support single inheritance is that new
functions added by a derived class be appended to the virtual table, while
overridden functions replace entries in their original positions.
            </p>
            <h3>Implementation</h3>
            <p>
Quite a bit of code is required to display the assembly and C implementations.
They are interesting, but very long and repetitive.  Click the
<code>details</code> elements below to view them.
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/single_inline.cpp">single_inline.cpp</a>
            </div>
            <pre class="inline-code"><code><b>struct</b> S {
    <b>virtual</b> <b>void</b> sf(<b>void</b>) {}
} s;

<b>struct</b> T : S {
    <b>virtual</b> <b>void</b> tf(<b>void</b>) {}
} t;

<b>struct</b> U : T {
    <b>virtual</b> <b>void</b> uf(<b>void</b>) {}
} u;

<b>void</b> f(S *p) {
    p-&gt;sf();
}

<b>void</b> f(T *p) {
    p-&gt;sf(), p-&gt;tf();
}

<b>void</b> f(U *p) {
    p-&gt;sf(), p-&gt;tf(), p-&gt;uf();
}</code></pre>
            <details class="inline-code-details">
                <summary>Assembly</summary>
                <pre><code>f(S*):
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>jmp</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
f(T*):
    <b>push</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b> <b>rbp</b>, <b>rdi</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>pop</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>8</b>[<b>rax</b>]
    <b>jmp</b> <b>rax</b>
f(U*):
    <b>push</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b> <b>rbp</b>, <b>rdi</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> <b>8</b>[<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>pop</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]
    <b>jmp</b> <b>rax</b>
vtable for S:
    <b>.quad</b> 0
    <b>.quad</b> 0
    <b>.quad</b> S::sf()
vtable for T:
    <b>.quad</b> 0
    <b>.quad</b> 0
    <b>.quad</b> S::sf()
    <b>.quad</b> T::tf()
vtable for U:
    <b>.quad</b> 0
    <b>.quad</b> 0
    <b>.quad</b> S::sf()
    <b>.quad</b> T::tf()
    <b>.quad</b> U::uf()
u:
    <b>.quad</b> vtable for U+16
t:
    <b>.quad</b> vtable for T+16
s:
    <b>.quad</b> vtable for S+16</code></pre>
            </details>
            <details class="code-details">
                <summary>Implementation</summary>
                <div>
                    <a class="src-ref" href="c++-virtual-tables/single.c">single.c</a>
                </div>
                <pre class="inline-code"><code><b>struct</b> S;
<b>struct</b> T;
<b>struct</b> U;

<b>struct</b> S_vtable {
    <b>void</b> (*<b>const</b> sf)(<b>struct</b> S*);
};

<b>struct</b> T_vtable {
    <b>struct</b> S_vtable S;
    <b>void</b> (*<b>const</b> tf)(<b>struct</b> T*);
};

<b>struct</b> U_vtable {
    <b>struct</b> T_vtable T;
    <b>void</b> (*<b>const</b> uf)(<b>struct</b> U*);
};

<b>struct</b> S {
    <b>const</b> <b>struct</b> S_vtable *vptr;
};

<b>struct</b> T {
    <b>union</b> {
        <b>const</b> <b>struct</b> T_vtable *vptr;
        <b>struct</b> S s;
    };
};

<b>struct</b> U {
    <b>union</b> {
        <b>const</b> <b>struct</b> U_vtable *vptr;
        <b>struct</b> T t;
    };
};

<b>void</b> S_sf(<b>struct</b> S*) {}
<b>void</b> T_tf(<b>struct</b> T*) {}
<b>void</b> U_uf(<b>struct</b> U*) {}

<b>const</b> <b>struct</b> {
    <b>const</b> <b>struct</b> vtable_header header;
    <b>const</b> <b>struct</b> S_vtable vtable;
} S_vtable = {
    .vtable.sf = S_sf,
};

<b>const</b> <b>struct</b> {
    <b>const</b> <b>struct</b> vtable_header header;
    <b>const</b> <b>struct</b> T_vtable vtable;
} T_vtable = {
    .vtable.S.sf = S_sf,
    .vtable.tf = T_tf,
};

<b>const</b> <b>struct</b> {
    <b>const</b> <b>struct</b> vtable_header header;
    <b>const</b> <b>struct</b> U_vtable vtable;
} U_vtable = {
    .vtable.T.S.sf = S_sf,
    .vtable.T.tf = T_tf,
    .vtable.uf = U_uf,
};

<b>struct</b> S s = {
    .vptr = &amp;S_vtable.vtable,
};

<b>struct</b> T t = {
    .vptr = &amp;T_vtable.vtable,
};

<b>struct</b> U u = {
    .vptr = &amp;U_vtable.vtable,
};

<b>void</b> f_S(<b>struct</b> S *p) {
    p-&gt;vptr-&gt;sf(p);
}

<b>void</b> f_T(<b>struct</b> T *p) {
    p-&gt;vptr-&gt;S.sf(&amp;p-&gt;s);
    p-&gt;vptr-&gt;tf(p);
}

<b>void</b> f_U(<b>struct</b> U *p) {
    p-&gt;vptr-&gt;T.S.sf(&amp;p-&gt;t.s);
    p-&gt;vptr-&gt;T.tf(&amp;p-&gt;t);
    p-&gt;vptr-&gt;uf(p);
}</code></pre>
                <pre class="inline-code"><code>f_S:
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>jmp</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
f_T:
    <b>push</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b> <b>rbp</b>, <b>rdi</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>pop</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>8</b>[<b>rax</b>]
    <b>jmp</b> <b>rax</b>
f_U:
    <b>push</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b> <b>rbp</b>, <b>rdi</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> <b>8</b>[<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>pop</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]
    <b>jmp</b> <b>rax</b>
u:
    <b>.quad</b> U_vtable+16
t:
    <b>.quad</b> T_vtable+16
s:
    <b>.quad</b> S_vtable+16
U_vtable:
    <b>.zero</b> <b>16</b>
    <b>.quad</b> S_sf
    <b>.quad</b> T_tf
    <b>.quad</b> U_uf
T_vtable:
    <b>.zero</b> <b>16</b>
    <b>.quad</b> S_sf
    <b>.quad</b> T_tf
S_vtable:
    <b>.zero</b> <b>16</b>
    <b>.quad</b> S_sf</code></pre>
            </details>
            <h2 id="non-virtual-bases-only">
                <a href="#non-virtual-bases-only">
                    Non-virtual bases only
                </a>
            </h2>
            <p>
For the constraints of this article, this category encompasses non-virtual
multiple inheritance, where a single class can derive directly from more than
one base.  The fundamental problem introduced by this category is that pointers
are no longer inter-convertible in general: they cannot point to objects of two
or more distinct types at the same time.  A pointer to the derived class can no
longer be used unchanged in all cases by functions expecting a pointer to one of
its bases, neither can its virtual table be used in this way.
            </p>
            <p>
This is a problem because functions ultimately defined in a base class (e.g.
<code>S</code> and <code>T</code> in the implementation above) expect a pointer
to an object of that type (<code>S*</code>/<code>T*</code>) as their
<code>this</code> pointer argument.  When calling these function, pointers to a
derived class have to be adjusted (offset).
            </p>
            <p>
Note that this also applies for single inheritance, which can be thought of as a
degenerate case where all offsets are zero.  For analogous reason, the top of a
class hierarchy (e.g.  <code>S</code> above), called the <i>primary base
class</i>, is special in that it can share the virtual table with the derived
type and avoid some of the complications described below.
            </p>
            <h3>Pointer adjustments</h3>
            <p>
Pointers may need adjustment in two distinct phases of a virtual call.
Initially, the pointer to the derived object is cast to a base pointer, which
involves offsetting it to point to a sub-object<a href="#note6"><sup>6</sup></a>.
This offset is done by the compiler whenever a cast occurs.  Since it knows the
source and destination types, it can generate the offset at compile time and
encode it in the machine code.
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/adj.cpp">adj.cpp</a>
            </div>
            <pre class="inline-code"><code><b>void</b> f(B*);

<b>void</b> g(D *p) {
    f(p);
}</code></pre>
            <pre class="inline-code"><code>g(D*):
    <b>lea</b>    <b>rax</b>, <b>16</b>[<b>rdi</b>]
    <b>test</b>   <b>rdi</b>, <b>rdi</b>
    <b>cmovne</b> <b>rdi</b>, <b>rax</b>
    <b>jmp</b>    f(B*)@PLT</code></pre>
            <p>
This sub-object needs to be indistinguishable from a regular object of the base
class.  Ultimately, this means each sub-object needs its own virtual table
&mdash; the derived object is no longer a concatenation of all classes with a
single virtual pointer at the top.  Even worse, it means a given class will have
multiple virtual tables: one for objects of that type and an additional one for
each hierarchy where that type appears in a sub-object due to multiple
inheritance.
            </p>
            <p>
In general, the reverse operation is not as trivial.  Given a base type, it is
not known to which concrete object it belongs and thus which offset to apply.
This is the reason for the "offset to top" value, the first member of the
virtual table: it contains the offset to be applied to reach the top of the
derived object (this also explains why it is always zero in a single-inheritance
hierarchy).
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/dyn.cpp">dyn.cpp</a>
            </div>
            <pre class="inline-code"><code><b>void</b> *f(B *p) {
    <b>return</b> <b>dynamic_cast</b>&lt;<b>void</b>*&gt;(p);
}</code></pre>
            <pre class="inline-code"><code>f(B*):
    <b>test</b> <b>rdi</b>, <b>rdi</b>
    <b>je</b> .L3
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>add</b> <b>rdi</b>, <b>QWORD</b> <b>PTR</b> <b>-16</b>[<b>rax</b>]
    <b>mov</b> <b>rax</b>, <b>rdi</b>
    <b>ret</b>
.L3:
    <b>xor</b> <b>eax</b>, <b>eax</b>
    <b>ret</b></code></pre>
            <h3>Function preludes</h3>
            <p>
When a pointer to a sub-object is used to call a function that is overridden by
a subclass, a second adjustment may be needed to point to the (sub-)object
expected by it.  A common way to deal with this offset is through the use of
<i>function preludes</i> (called <i>thunks</i> in the Itanium ABI).  This is a
short code fragment which performs the pointer adjustment before executing the
original function (called the <i>non-adjusting entry point</i>).  The address of
this fragment is what is then placed in the virtual table.
            </p>
            <p>
Preludes can sometimes be located right before the original function, in which
case no change in control flow is necessary: the instruction stream can simply
flow into the original function after the pointer is adjusted.  Most commonly,
they are placed in the same object file and perform a call or direct jump at the
end.  They may also be used for other purposes, such as adjustments for
covariant return types.
            </p>
            <h3>Implementation</h3>
            <p>
Here is the final implementation, supporting class hierarchies with multiple
inheritance.  A variant of this source is what is defined in the
<code>evil.c</code> presented at the beginning of the article.  There, the
objects and functions are carefully named to coincide with the mangled names the
compiler would generate so that the linker finds them when it looks for the
implementation.  This is completely undefined behavior (for this exact reason),
but is done here to demonstrate that the implementation of virtual dispatch is
valid.
            </p>
            <div>
                <a class="src-ref" href="c++-virtual-tables/multiple_inline.cpp">multiple_inline.cpp</a>
            </div>
            <pre class="inline-code"><code><b>struct</b> S {
    <b>virtual</b> <b>void</b> sf(<b>void</b>) {}
} s;

<b>struct</b> T {
    <b>virtual</b> <b>void</b> tf(<b>void</b>) {}
} t;

<b>struct</b> U : S, T {
    <b>void</b> tf(<b>void</b>) <b>override</b> {}
    <b>virtual</b> <b>void</b> uf(<b>void</b>) {}
} u;

<b>void</b> f(S *p) {
    p-&gt;sf();
}

<b>void</b> f(T *p) {
    p-&gt;tf();
}

<b>void</b> f(U *p) {
    p-&gt;sf(), p-&gt;tf(), p-&gt;uf();
}</code></pre>
            <details class="inline-code-details">
                <summary>Assembly</summary>
                <pre class="inline-code"><code>non-virtual thunk to U::tf():
    <b>sub</b> <b>rdi</b>, <b>8</b>
    <b>jmp</b> U::tf
f(S*):
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>jmp</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
f(T*):
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>jmp</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
f(U*):
    <b>push</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b> <b>rbp</b>, <b>rdi</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> 8[<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>pop</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]
    <b>jmp</b> <b>rax</b>
vtable for S:
    <b>.quad</b> <b>0</b>
    <b>.quad</b> <b>0</b>
    <b>.quad</b> S::sf()
vtable for T:
    <b>.quad</b> <b>0</b>
    <b>.quad</b> <b>0</b>
    <b>.quad</b> T::tf()
vtable for U:
    <b>.quad</b> <b>0</b>
    <b>.quad</b> <b>0</b>
    <b>.quad</b> S::sf()
    <b>.quad</b> U::tf()
    <b>.quad</b> U::uf()
    <b>.quad</b> -<b>8</b>
    <b>.quad</b> <b>0</b>
    <b>.quad</b> non-virtual
          thunk to U::tf()
s:
    <b>.quad</b> vtable for S+16
t:
    <b>.quad</b> vtable for T+16
u:
    <b>.quad</b> vtable for U+16
    <b>.quad</b> vtable for U+56</code></pre>
            </details>
            <details class="code-details">
                <summary>Implementation</summary>
                <div>
                    <a class="src-ref" href="c++-virtual-tables/multiple_inline.c">multiple_inline.c</a>
                </div>
                <pre class="inline-code"><code><b>struct</b> S;
<b>struct</b> T;
<b>struct</b> U;

<b>struct</b> S_vtable {
    <b>void</b> (*<b>const</b> sf)(<b>struct</b> S*);
};

<b>struct</b> T_vtable {
    <b>void</b> (*<b>const</b> tf)(<b>struct</b> T*);
};

<b>struct</b> U_vtable {
    <b>const</b> <b>struct</b> S_vtable S;
    <b>const</b> <b>struct</b> T_vtable T;
    <b>void</b> (*<b>const</b> uf)(<b>struct</b> U*);
};

<b>struct</b> S {
    <b>const</b> <b>struct</b> S_vtable *vptr;
};

<b>struct</b> T {
    <b>const</b> <b>struct</b> T_vtable *vptr;
};

<b>struct</b> U {
    <b>union</b> {
        <b>const</b> <b>struct</b> U_vtable *vptr;
        <b>struct</b> S s;
    };
    <b>struct</b> T t;
};

<b>void</b> S_sf(<b>struct</b> S*) {}
<b>void</b> T_tf(<b>struct</b> T*) {}
<b>void</b> U_tf(<b>struct</b> U*) {}
<b>void</b> U_uf(<b>struct</b> U*) {}

<b>void</b> U_t_tf(<b>struct</b> T* p) {
    U_tf(container_of(p, <b>struct</b> U, t));
}

<b>const</b> <b>struct</b> {
    <b>const</b> <b>struct</b> vtable_header header;
    <b>const</b> <b>struct</b> S_vtable vtable;
} S_vtable = {
    .vtable.sf = S_sf,
};

<b>const</b> <b>struct</b> {
    <b>const</b> <b>struct</b> vtable_header header;
    <b>const</b> <b>struct</b> T_vtable vtable;
} T_vtable = {
    .vtable.tf = T_tf,
};

<b>const</b> <b>struct</b> {
    <b>const</b> <b>struct</b> vtable_header header;
    <b>const</b> <b>struct</b> U_vtable vtable;
    <b>const</b> <b>struct</b> vtable_header T_header;
    <b>const</b> <b>struct</b> T_vtable T_vtable;
} U_vtable = {
    .vtable.S.sf = S_sf,
    .vtable.T.tf =
        (<b>void</b>(*)(<b>struct</b> T*))U_tf,
    .vtable.uf = U_uf,
    .T_header.offset_to_top =
        -<b>offsetof</b>(<b>struct</b> U, t),
    .T_vtable.tf = U_t_tf,
};

<b>struct</b> S s = {
    .vptr = &amp;S_vtable.vtable,
};

<b>struct</b> T t = {
    .vptr = &amp;T_vtable.vtable,
};

<b>struct</b> U u = {
    .vptr = &amp;U_vtable.vtable,
    .t.vptr = &amp;U_vtable.T_vtable,
};

<b>void</b> f_S(<b>struct</b> S *p) {
    p-&gt;vptr-&gt;sf(p);
}

<b>void</b> f_T(<b>struct</b> T *p) {
    p-&gt;vptr-&gt;tf(p);
}

<b>void</b> f_U(<b>struct</b> U *p) {
    p-&gt;vptr-&gt;S.sf(&amp;p-&gt;s);
    p-&gt;vptr-&gt;T.tf((<b>struct</b> T*)p);
    p-&gt;vptr-&gt;uf(p);
}</code></pre>
                <pre class="inline-code"><code>U_t_tf:
    <b>sub</b> <b>rdi</b>, <b>8</b>
    <b>jmp</b> U_tf@PLT
f_S:
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>jmp</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
f_T:
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>jmp</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
f_U:
    <b>push</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b> <b>rbp</b>, <b>rdi</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> [<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> <b>8</b>[<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>pop</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]
    <b>jmp</b> <b>rax</b>
S_vtable:
    <b>.zero</b> <b>16</b>
    <b>.quad</b> S_sf
T_vtable:
    <b>.zero</b> <b>16</b>
    <b>.quad</b> T_tf
U_vtable:
    <b>.zero</b> <b>16</b>
    <b>.quad</b> S_sf
    <b>.quad</b> U_tf
    <b>.quad</b> U_uf
    <b>.quad</b> -<b>8</b>
    <b>.zero</b> <b>8</b>
    <b>.quad</b> U_t_tf
s:
    <b>.quad</b> S_vtable+16
t:
    <b>.quad</b> T_vtable+16
u:
    <b>.quad</b> U_vtable+16
    <b>.quad</b> U_vtable+56</code></pre>
            </details>
            <h2 id="references">
                <a href="#references">
                    References
                </a>
            </h2>
            <p>
This article was the result of my frustration when researching this topic.  It
tries to provide an intermediate step between the abundant basic introductions
and the quasi-inscrutable reference manuals.  For this reason, and despite its
length, it leaves much to be explored.  Here are some pointers (<i>heh</i>) for
further reading:
            </p>
            <ul>
                <li>
                    <p>
As mentioned previously, virtual inheritance significantly complicates the
implementation of virtual dispatch.  It does so, however, in a mostly
non-intrusive way with regards to what was presented.
                    </p>
                </li>
                <li>
                    <p>
Constructors must initialize the virtual pointer(s) and must ensure that they
are valid at all points as defined by the standard.  Destructors are also
virtual functions whose implementation needs some care.
                    </p>
                </li>
                <li>
                    <p>
In general, an immense amount of detail has been omitted &mdash; destructor
variants, covariant return types, construction tables, to name a few.
                    </p>
                </li>
                <li>
                    <p>
Bjarne Stroustrup's original
<a href="https://www.usenix.org/legacy/publications/compsystems/1989/fall_stroustrup.pdf">article</a>
on the C++ implementation, <i>Multiple Inheritance for C++</i>, is a very good
summary and introduction.
                    </p>
                </li>
                <li>
                    <p>
Morgan Deters' <a href="https://ww2.ii.uj.edu.pl/~kapela/pn/cpp_vtable.html">notes</a>,
<i>VTable Notes on Multiple Inheritance in GCC C++ Compiler v4.0.1</i>, provide
a nice visual accompaniment to these descriptions, especially for the virtual
inheritance cases.
                    </p>
                </li>
                <li>
                    <p>
Axel-Tobias Schreiner's book, <i>Object-Oriented Programming With ANSI-C</i>, is
a phenomenal book on the topic.  The C implementation presented here makes no
attempt to be usable, it is a simple, reverse-engineered, glorified disassembly
of the compiler output.  Schreiner's books has an incredibly elegant and
beautiful implementation of single-inheritance in C.  The book is available
<a href="https://www.lulu.com/content/paperback-book/object-oriented-programming-with-ansi-c/11642626">in print</a>
and <a href="https://www.cs.rit.edu/~ats/books">online</a>.
                    </p>
                </li>
                <li>
                    <p>
Neil Brown's <a href="https://lwn.net/Articles/444910">series</a> in LWN, <i>
Object-oriented design patterns in the kernel</i>, explores the manifestation of
many of these patterns &mdash; some less orthodox than others &mdash; in the
Linux kernel, where object-oriented programming is heavily used.
                    </p>
                </li>
            </ul>
            <p>
I hope this was helpful.  Happy hacking.
            </p>
            <h2 id="notes">
                <a href="#notes">
                    Notes
                </a>
            </h2>
            <ol start="0">
                <li id="note0">
                    <p>
C++ requires <code>sizeof(x) &gt; 0</code> for all objects.
                    </p>
                </li>
                <li id="note1">
                    <p>
<code>lea</code> is the <i>load effective address</i> x86 instruction.  In this
case, it is a simpler (to the assembler) form of adding the
address of <code>s</code> to <code>rip</code> (the instruction pointer).  Both
this offset and the reference to <code>@PLT</code> are due to the fact that GCC
builds <i>position-independent code</i> (PIC) by default, i.e. code that can be
placed in shared libraries and dynamically loaded at runtime.
                    </p>
                </li>
                <li id="note2">
                    <p>
The actual implementation generated by the compiler is not as simple:
                    </p>
                    <pre><code>f(S*):
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>lea</b> <b>rdx</b>, S::f()[<b>rip</b>]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rax</b>]
    <b>cmp</b> <b>rax</b>, <b>rdx</b>
    <b>jne</b> .L5
    <b>ret</b>
.L5:
    <b>jmp</b> <b>rax</b></code></pre>
                    <p>
To arrive at the machine code in the main text, the definition of
<code>S::f</code> was removed, leaving only its declaration.  The reason for
this is that if the compiler can see the (trivial) implementation of the
function, it can decide to inline the call.  In this case, there is no
implementation to inline, but the function code would be added between the
<code>jne</code> and <code>ret</code> instructions if it existed.
                    </p>
                    <p>
This is only a valid optimization if the function has not been overridden
(<code>p</code> may point to a subclass of <code>S</code> since it is not
declared <code>final</code>), which is the reason for the extra comparison.  The
address in the object's virtual table is compared to the address of
<code>S::f</code>, and jumped into if it is a different (i.e. overridden)
function.
                    </p>
                    <p>
The implementation according to the C version presented later in the article
which generates the same machine code is:
                    </p>
                    <a class="src-ref" href="c++-virtual-tables/leaf_inline.c">leaf_inline.c</a>
                    <pre><code><b>void</b> f(<b>struct</b> S *p) {
    <b>void</b> (*f)(<b>struct</b> S*) = p-&gt;vptr-&gt;f;
    __builtin_expect(f == S_f, <b>1</b>) ? S_f(p) : f(p);
}</code></pre>
                </li>
                <li id="note3">
                    <p>
Which amusingly can also be written as <code>n[array]</code>, with the same
semantics and mirroring the assembly syntax.
                    </p>
                </li>
                <li id="note4">
                    <p>
A very subtle aspect of the implementation generated by the compiler here is
that the virtual table is reloaded after each virtual call (from
<code>rbp</code>, since <code>rdi</code> is a caller-saved register).  From the
compiler's perspective, this is because the functions, which are opaque since
they are behind pointers, have access to the object through the argument
<code>p</code> and could change the pointer and even the contents of the table.
                    </p>
                    <p>
Doing so, however, would be undefined behavior since the layout of objects with
virtual functions is not defined (it need not even involve a virtual pointer at
all).  Exposing enough information to the compiler back end to take advantage of
this optimization is an active area of research (e.g.
<a href="https://arxiv.org/pdf/2003.04228.pdf"><i>Modeling the Invariance of Virtual Pointers in LLVM</i></a>).
                    </p>
                    <p>
We can emulate this in our C implementation, compare:
                    </p>
                    <div>
                        <a class="src-ref" href="c++-virtual-tables/multiple_reload.cpp">multiple_reload.cpp</a>
                    </div>
                    <pre class="inline-code"><code><b>void</b> f(U *p) {
    p-&gt;uf();
    p-&gt;uf();
    p-&gt;uf();
    p-&gt;uf();
}</code></pre>
                    <pre class="inline-code"><code>f(U*):
    <b>push</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b> <b>rbp</b>, <b>rdi</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>call</b> [<b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]]
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>0</b>[<b>rbp</b>]
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>pop</b> <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]
    <b>jmp</b> <b>rax</b></code></pre>
                    <p>vs.</p>
                    <div>
                        <a class="src-ref" href="c++-virtual-tables/multiple_reload.c">multiple_reload.c</a>
                    </div>
                    <pre class="inline-code"><code><b>void</b> f_U(<b>struct</b> U *p) {
    <b>void</b> (*f)(<b>struct</b> U*) =
        p-&gt;vptr-&gt;uf;
    f(p);
    f(p);
    f(p);
    f(p);
}</code></pre>
                    <pre class="inline-code"><code>f_U:
    <b>push</b> <b>rbp</b>
    <b>mov</b> <b>rbp</b>, <b>rdi</b>
    <b>push</b> <b>rbx</b>
    <b>sub</b> <b>rsp</b>, <b>8</b>
    <b>mov</b> <b>rax</b>, <b>QWORD</b> <b>PTR</b> [<b>rdi</b>]
    <b>mov</b> <b>rbx</b>, <b>QWORD</b> <b>PTR</b> <b>16</b>[<b>rax</b>]
    <b>call</b> <b>rbx</b>
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>call</b> <b>rbx</b>
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>call</b> <b>rbx</b>
    <b>add</b> <b>rsp</b>, <b>8</b>
    <b>mov</b> <b>rdi</b>, <b>rbp</b>
    <b>mov</b> <b>rax</b>, <b>rbx</b>
    <b>pop</b> <b>rbx</b>
    <b>pop</b> <b>rbp</b>
    <b>jmp</b> <b>rax</b></code></pre>
                    <p>
Whether this is a beneficial optimization depends on caching behavior and the
implementation of <code>f</code> and the function(s) being called.
                    </p>
                </li>
                <li id="note5">
                    <p>
This is true, both in C and C++, even for unrelated <code>struct</code>s when
there is a common prefix.  C++ 20 provides several type traits to verify that
this relation exists for a pair of types:
                    </p>
                    <ul>
                        <li>
                            <a href="https://en.cppreference.com/w/cpp/types/is_layout_compatible">std::is_layout_compatible</a>
                        </li>
                        <li>
                            <a href="https://en.cppreference.com/w/cpp/types/is_pointer_interconvertible_base_of">std::is_pointer_interconvertible_base_of</a>
                        </li>
                        <li>
                            <a href="https://en.cppreference.com/w/cpp/types/is_pointer_interconvertible_with_class">std::is_pointer_interconvertible_with_class</a>
                        </li>
                        <li>
                            <a href="https://en.cppreference.com/w/cpp/types/is_corresponding_member">std::is_corresponding_member</a>
                        </li>
                    </ul>
                </li>
                <li id="note6">
                    <p>
Allow me a short diatribe.  You <b><em>do not</em></b> need dynamic memory
allocation for dynamic dispatch.  This will work just fine:
                    </p>
                    <pre><code>D d;
B *b = &amp;d;
b-&gt;vfn();</code></pre>
                    <p>
As will <code>static_cast&lt;B*&gt;(&amp;d)-&gt;vfn()</code>.  It annoys me to no
end to see <code>B *b = new D</code> or similar atrocities in dynamic dispatch
examples.
                    </p>
                </li>
            </ol>
            <div class="tags">
                <a href="tags/assembly.html">assembly</a>
                <a href="tags/c.html">c</a>
                <a href="tags/c++.html">c++</a>
                <a href="tags/linux.html">linux</a>
                <a href="tags/programming.html">programming</a>
                <a href="tags/unix.html">unix</a>
            </div>
        </main>
    </body>
</html>
